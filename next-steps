# Game Persistence, Lives System & Leaderboard Specification

## Overview
Add local persistence, formal database backend, lives/score threshold mechanics, and competitive leaderboard to Cosmic Match-3.

## Architecture Decisions

### Storage Strategy
1. **Local Storage** - Game progress, settings, in-progress games
2. **Backend Database** - Shop items, leaderboard, player stats
3. **Backend Choice**: **Supabase** (recommended)
   - Free tier available
   - PostgreSQL database
   - Built-in auth (for future features)
   - Real-time subscriptions
   - Good TypeScript support

## Feature 1: Local Storage Persistence

### Data to Persist Locally
```typescript
interface SavedGameState {
  gameId: string;                    // Unique ID for this playthrough
  currentRound: number;              // Current round (1-10)
  totalScore: number;                // Cumulative score
  roundScores: number[];             // Array of completed round scores
  lives: number;                     // Remaining lives
  availablePoints: number;           // Unspent shop points
  spentPoints: number;               // Total spent
  ownedUpgrades: PurchasedUpgrade[]; // Active upgrades
  timestamp: string;                 // Last save time
  isComplete: boolean;               // Game finished?
}

interface PurchasedUpgrade {
  upgradeId: string;
  purchaseCount: number;
  roundPurchased: number;
}

interface PlayerSettings {
  playerName: string;                // For leaderboard submission
  soundEnabled: boolean;
  musicEnabled: boolean;
}
```

### LocalStorage Manager
```typescript
export class LocalStorageManager {
  private static GAME_KEY = 'cosmic_matcher_save';
  private static SETTINGS_KEY = 'cosmic_matcher_settings';
  
  // Game State
  static saveGame(state: SavedGameState): void;
  static loadGame(): SavedGameState | null;
  static clearGame(): void;
  static hasActiveSave(): boolean;
  
  // Settings
  static saveSettings(settings: PlayerSettings): void;
  static loadSettings(): PlayerSettings;
}
```

### Implementation Steps: Local Storage
1. **Create `src/services/LocalStorageManager.ts`**
2. **Auto-save triggers:**
   - After each round completion
   - When lives are lost
3. **Add "Continue Game" option to menu**
4. **Add "New Game" option that clears save**

## Feature 2: Lives & Score Threshold System

### Game Design
```typescript
interface RoundRequirements {
  round: number;
  timeLimit: number;         // Seconds (decreasing)
  minimumScore: number;      // Required to pass
  livesLost: number;         // 1 if failed, 0 if passed
}

// Score thresholds (suggested - tune for balance)
const ROUND_THRESHOLDS = [
  { round: 1, minScore: 500, time: 60 },
  { round: 2, minScore: 600, time: 60 },
  { round: 3, minScore: 800, time: 60 },
  { round: 4, minScore: 1000, time: 60 },
  { round: 5, minScore: 1200, time: 60 },
  { round: 6, minScore: 1400, time: 60 },
  { round: 7, minScore: 1800, time: 60 },
  { round: 8, minScore: 2000, time: 60 },
  { round: 9, minScore: 2500, time: 60 },
  { round: 10, minScore: 3000, time: 60 }
];

const STARTING_LIVES = 3;
```

### Lives System Logic
```typescript
export class LivesManager {
  private lives: number = STARTING_LIVES;
  
  checkRoundCompletion(round: number, score: number): RoundResult {
    const threshold = ROUND_THRESHOLDS[round - 1];
    const passed = score >= threshold.minScore;
    
    if (!passed) {
      this.lives--;
    }
    
    return {
      passed,
      livesRemaining: this.lives,
      isGameOver: this.lives <= 0,
      threshold: threshold.minScore,
      score
    };
  }
  
  getLives(): number;
  isGameOver(): boolean;
}
```

### UI Changes for Lives System
1. **Display lives count** in main game UI (e.g., ❤️❤️❤️)
2. **Show score threshold** during round (e.g., "Target: 500")
3. **Round fail screen** (separate from transition):
   - "Round Failed! Score: X (needed Y)"
   - Show remaining lives
   - Option to continue or give up
4. **Game Over screen enhancements:**
   - Show reason: "All lives lost" or "10 rounds complete"
   - Prompt for leaderboard submission

## Feature 3: Database Backend (Supabase)

### Database Schema

#### Table: `shop_items`
```sql
CREATE TABLE shop_items (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT NOT NULL,
  base_cost INTEGER NOT NULL,
  effect_type TEXT NOT NULL,
  effect_value NUMERIC NOT NULL,
  max_purchases INTEGER NOT NULL,
  icon_url TEXT,
  sort_order INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### Table: `leaderboard`
```sql
CREATE TABLE leaderboard (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  player_name TEXT NOT NULL,
  total_score INTEGER NOT NULL,
  rounds_completed INTEGER NOT NULL,
  lives_remaining INTEGER NOT NULL,
  game_completed BOOLEAN NOT NULL,
  upgrades_purchased JSONB,
  play_date TIMESTAMP DEFAULT NOW(),
  game_duration_seconds INTEGER,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_leaderboard_score ON leaderboard(total_score DESC);
CREATE INDEX idx_leaderboard_date ON leaderboard(play_date DESC);
```

### Supabase Setup Steps
1. **Create Supabase project** at supabase.com
2. **Get credentials:**
   - Project URL
   - Anon public key
3. **Install client:**
   ```bash
   npm install @supabase/supabase-js
   ```
4. **Create `.env` file:**
   ```
   VITE_SUPABASE_URL=your_project_url
   VITE_SUPABASE_ANON_KEY=your_anon_key
   ```
5. **Add to `.gitignore`:**
   ```
   .env
   .env.local
   ```

### Supabase Service
```typescript
import { createClient, SupabaseClient } from '@supabase/supabase-js';

export class DatabaseService {
  private supabase: SupabaseClient;
  
  constructor() {
    this.supabase = createClient(
      import.meta.env.VITE_SUPABASE_URL,
      import.meta.env.VITE_SUPABASE_ANON_KEY
    );
  }
  
  // Shop Items
  async getShopItems(): Promise<ShopItem[]>;
  async getActiveShopItems(): Promise<ShopItem[]>;
  
  // Leaderboard
  async submitScore(entry: LeaderboardEntry): Promise<void>;
  async getTopScores(limit: number = 10): Promise<LeaderboardEntry[]>;
  async getRecentScores(limit: number = 20): Promise<LeaderboardEntry[]>;
  async getPlayerRank(score: number): Promise<number>;
}
```

### Shop System Migration
```typescript
// OLD: Hard-coded shop items
const shopItems = [...]

// NEW: Fetch from database
export class ShopSystem {
  private db: DatabaseService;
  private cachedItems: ShopItem[] | null = null;
  
  async loadShopItems(): Promise<ShopItem[]> {
    if (this.cachedItems) return this.cachedItems;
    
    this.cachedItems = await this.db.getShopItems();
    return this.cachedItems;
  }
}
```

## Feature 4: Leaderboard System

### Leaderboard Entry
```typescript
interface LeaderboardEntry {
  id?: string;
  playerName: string;
  totalScore: number;
  roundsCompleted: number;
  livesRemaining: number;
  gameCompleted: boolean;
  upgradesPurchased: PurchasedUpgrade[];
  playDate: string;
  gameDurationSeconds: number;
}
```

### LeaderboardScene
```typescript
export class LeaderboardScene extends Phaser.Scene {
  private db: DatabaseService;
  
  async create(): Promise<void> {
    // Display options: Top 10, Recent 20
    // Show: Rank, Name, Score, Rounds, Date
    // Filter: All time, Today, This week
  }
  
  private async displayTopScores(): Promise<void>;
  private async displayRecentScores(): Promise<void>;
}
```

### Score Submission Flow
```typescript
export class GameOverScene extends Phaser.Scene {
  async submitToLeaderboard(): Promise<void> {
    // Get player name from settings or prompt
    const playerName = this.getPlayerName();
    
    const entry: LeaderboardEntry = {
      playerName,
      totalScore: this.gameProgress.totalScore,
      roundsCompleted: this.gameProgress.currentRound,
      livesRemaining: this.livesManager.getLives(),
      gameCompleted: this.gameProgress.currentRound === 10,
      upgradesPurchased: this.gameProgress.ownedUpgrades,
      playDate: new Date().toISOString(),
      gameDurationSeconds: this.calculateDuration()
    };
    
    await this.db.submitScore(entry);
    
    // Show rank
    const rank = await this.db.getPlayerRank(entry.totalScore);
    this.showRankAchievement(rank);
  }
}
```

## Implementation Phases

### Phase 1: Local Storage (Start Here)
1. Create `LocalStorageManager`
2. Update `GameProgressManager` to auto-save
3. Add "Continue Game" to menu
4. Test save/load cycle

**Testing:**
- Save game mid-progress, refresh browser, verify continue works
- Complete game, verify save clears
- Test multiple save/load cycles

### Phase 2: Lives System
1. Create `LivesManager`
2. Define `ROUND_THRESHOLDS`
3. Update round completion logic
4. Create round fail UI
5. Update game over conditions

**Testing:**
- Intentionally fail rounds to test life loss
- Verify game over when lives = 0
- Test threshold progression

### Phase 3: Database Setup
1. Create Supabase account and project
2. Run SQL schema creation
3. Seed `shop_items` table with existing items
4. Install Supabase client
5. Create `DatabaseService`
6. Test connection

**Testing:**
- Verify shop items load from database
- Test error handling for network failures
- Add fallback to hard-coded items if DB unavailable

### Phase 4: Leaderboard
1. Create leaderboard submission logic
2. Create `LeaderboardScene`
3. Add leaderboard button to menu
4. Test score submission
5. Add player name prompt

**Testing:**
- Submit test scores
- Verify ranking calculation
- Test leaderboard display
- Check date filtering

## Files to Create

### Services
- `src/services/LocalStorageManager.ts`
- `src/services/DatabaseService.ts`
- `src/services/LivesManager.ts`

### Scenes
- `src/scenes/LeaderboardScene.ts`
- `src/scenes/RoundFailScene.ts` (optional - can modify RoundTransition)
- `src/scenes/NameEntryScene.ts` (for leaderboard submission)

### Types
- `src/types/Storage.ts`
- `src/types/Leaderboard.ts`

### Config
- `.env` (Supabase credentials)
- `src/config/supabase.ts` (Supabase client config)

## Environment Variables Setup

Create `.env.example` (commit this):
```
VITE_SUPABASE_URL=your_supabase_url_here
VITE_SUPABASE_ANON_KEY=your_anon_key_here
```

Add to Netlify:
1. Site settings → Environment variables
2. Add both variables
3. Redeploy

## Database Seed Data

```sql
-- Initial shop items
INSERT INTO shop_items (id, name, description, base_cost, effect_type, effect_value, max_purchases, sort_order) VALUES
('time_bonus', 'Time Boost', '+5 seconds to round timer', 500, 'time_add', 5, 3, 1),
('score_multiplier', 'Score Multiplier', '+20% score for next round', 800, 'score_multiply', 1.2, 5, 2),
('combo_boost', 'Combo Master', 'Combos give +50% more time', 1000, 'combo_time', 1.5, 2, 3),
('lucky_start', 'Lucky Board', 'Start round with guaranteed matches', 600, 'lucky_board', 1, 1, 4);
```

## UI/UX Enhancements

### Main Game Display
```
┌─────────────────────────────────────┐
│ Round 3/10    ❤️❤️❤️    Score: 2450 │
│ Target: 700   Time: 0:45             │
└─────────────────────────────────────┘
```

### Round Fail Screen
```
╔═══════════════════════════╗
║   ROUND 3 FAILED!        ║
║                          ║
║   Score: 650             ║
║   Needed: 700            ║
║                          ║
║   Lives: ❤️❤️ (2)        ║
║                          ║
║   [Continue] [Give Up]   ║
╚═══════════════════════════╝
```

## Testing Checklist

### Local Storage
- [ ] Game saves after round completion
- [ ] Game saves after shop purchase
- [ ] Continue game loads correct state
- [ ] New game clears old save
- [ ] Browser refresh doesn't lose progress

### Lives System
- [ ] Lives display correctly
- [ ] Score threshold shows during round
- [ ] Failing round removes life
- [ ] Game over at 0 lives
- [ ] Can complete game with lives remaining

### Database
- [ ] Shop items load from Supabase
- [ ] Graceful fallback if DB unavailable
- [ ] Leaderboard submissions work
- [ ] Leaderboard displays correctly
- [ ] Rank calculation accurate

### Integration
- [ ] Full playthrough with save/resume
- [ ] Submit score to leaderboard
- [ ] Verify leaderboard entry appears
- [ ] Test with network offline

## Success Criteria
- Player can resume interrupted games
- Lives system creates meaningful tension
- Shop items managed via database (easy to add/modify)
- Leaderboard encourages replayability
- No data loss on browser refresh